데이터를 저장하는 기법

마지막 상태를 보관하는것과 함께 기록을 남긴다.

문제는 기록은 도메인에 완전한 사실들을 남기지 않는다.
상태를 기록하는 행위와 로그를 남기는 것은 원자성을 가지 않는다.

이벤트 소싱은 이벤트를 저장하고 이 이벤트를 재생해서 상태를 만든다.
이벤트가 저장 대상이고 상태는 저장대상이 아님(기존과 다르게)
영속 대상은 이벤트이다. 오직 추가되기만 한다.

>마틴파울러  
이런 방식으로 동작하는 것들 : 버전관리시스템

이벤트 저장소는 수많은 이벤트 스트리므로 구성됨
모메인 오브젝트 하나당 하나의 이벤트저장소

커맨드는 검증대상이다.
명령이 올바른지 아닌지. 실패할 가능성이 있다.
명령은 명령형 동사르 사용해서 이름을 짓는다.

이벤트는 이미 지나간 사실, 돌이킬 수 없다. 항상 성공함
과거형 동사를 사용함

이벤트는
키와 벨류로 이루어짐
key : objectid, version
value : event type, serialized payload

객체관계와 임피던스 불일치가 문제가 생김

이벤트가 굉장이 많은 경우 복원하기가 힘드니까 스냅샷을 찍어준다.
key:objectid
value : version, serialized state

메시지 드리븐 아키텍처랑 궁합이 잘 맞는다.

명령을 받아 처리한 후 다른 시스템 에 다시 메시지를 보내는 서비스

분산시스템에서 어려운 점
1. 정확히 한번 배달
2. 메시지 순서 보장

최소 한번 배달! 메시지에 멱등성을 확보해야 할 필요가 있다. 두번 전달해도 결과값이 다르지 않다.
커맨드에 재고 5개를 늘리는 이벤트가 있는데 이게 두번오면 계속 늘어남
커맨드에 재고 15개가 됐다. 이건 멱등이다.

이벤트 스트림은 모데인 객체별로 있다. 순서보장도 그 도메인 객체별로 하면 별 문제가 없다.

CQRS
재고가 10개 미만인 상품 목록이 필요합니다.
이벤트 소싱은 이론적으로는 cqrs와 종학하지 않지만 실제는 같이 쓴다.

CQS
질문은 대답을 변경하지 않는다.
상태를 변경하되 리턴값을 갖지 안는 것

개체 자체에 개념을 나눠라. 시스템과 어플을 구분

이벤트는 반드시 영구저장소에 저장한다.

최종상태를 알기 위해서는 모든 이벤트를 재생해야한다. 많으면 오래 걸린다. 그래서 스냅샷을 찍어 놓는다.
구성 : 이벤트 식별자, 버전, 리플레이된 도메인객체
그래도 느리다.

이벤트 소싱에서 CQRS는 거의 필수다.


